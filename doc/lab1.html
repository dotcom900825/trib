<h2>
<a name="lab1" class="anchor" href="#lab1"><span class="octicon octicon-link"></span></a>Lab1</h2>

<p>Welcome to Lab1. The goal of this lab is to split the logic into
stateless scalable front-ends and a key-value pair backend. In
particular, you need to:</p>

<ol>
<li>Implement a key-value storage server type that fits <code>trib.Store</code>
interface and takes http RPC requests from the network.</li>
<li>Implement a key-value storage client type that fits <code>trib.Store</code>
interface and RPCs a remote key-value pair server.</li>
<li>Implement a stateless Tribbler front-end type that fits
<code>trib.Server</code> interface that calls a remote RPC key-value pair
back-end server.</li>
</ol><p>More specifically, you need to implement three entry functions that
are defined in <code>triblab/entries.go</code> file: <code>ServeBack()</code>, <code>NewClient()</code>
and <code>NewFront()</code>. Now, they are all placeheld by <code>panic("todo")</code>.</p>

<h2>
<a name="tribble" class="anchor" href="#tribble"><span class="octicon octicon-link"></span></a>Tribble</h2>

<p>A Tribble is a structure type that has 4 fields:</p>

<pre><code>type Trib struct {
    User    string    // who posted this trib
    Message string    // the content of the trib
    Time    time.Time // the physical timestamp
    Clock   uint64    // the logical clock
}
</code></pre>

<p><code>Time</code> is what the front-end claims when this tribble is created,
by reading the front-end's own physical time clock on the machine when
<code>Post()</code> is called. However, to sort tribbles in a globally 
consistent and reasonable order, this timestamp cannot be used
because different front-ends have different physical time readings.
Tribbler service maintains a distributed logical <code>Clock</code> in <code>uint64</code>
for sorting.</p>

<p>When sorting many tribbles into a single timeline, you should sort by
the fields following this priority:</p>

<ol>
<li>
<code>Clock</code> The logical timestamp.</li>
<li>
<code>Time</code> The physical timestamp.</li>
<li>
<code>User</code> The user id</li>
<li>
<code>Message</code> The message content.</li>
</ol><p>We call this the <em>Tribble Order</em>.</p>

<h2>
<a name="tribbler-service-interface" class="anchor" href="#tribbler-service-interface"><span class="octicon octicon-link"></span></a>Tribbler Service Interface</h2>

<p>The Tribbler service logic is all defined in <code>trib.Server</code> interface
(in <code>trib/trib.go</code> file).</p>

<hr><pre><code>SignUp(user string) error
</code></pre>

<p>Creates a new user. After a user is created, it will always exist.  A
user name must be no longer than <code>trib.MaxUsernameLen=15</code> characters
but not empty, must start with a lower-case letter, and can only
contain lower-case letters or numbers.</p>

<p>There is a helper function called <code>trib.IsValidUsername(string)</code> which
you can use to check if a username is valid.</p>

<p>Returns error when the username is invalid or the user already exists.
Concurrent sign-ups might both succeed.</p>

<hr><pre><code>ListUsers() ([]string, error)
</code></pre>

<p>Lists at least <code>trib.MinListUser = 20</code> different registered users.
When there are less than 20 users that have ever signed up, list all
of them. The returned usernames should be sorted in alphabetical.</p>

<p>This is for showing some users on the front page.  This is not for
listing all the users that have ever signed up, because that would be
too expensive in a scalable system.</p>

<hr><pre><code>Post(who, post string, clock uint64) error
</code></pre>

<p>Posts a tribble. <code>clock</code> is the maximum clock value this user client
has ever seen so far by reading tribbles (via <code>Home()</code> and <code>Tribs()</code>).
It returns error when the user does not exist or the post is too long
(longer than <code>trib.MaxTribLen=140</code>).</p>

<hr><pre><code>Tribs(user string) ([]*Trib, error)
</code></pre>

<p>Lists the recent <code>trib.MaxTribFetch=100</code> tribbles that a user posted.
Tribbles needs to be sorted in Tribble Order. Also, it should make
sure that the order is the same order that the user posted the
tribbles.</p>

<hr><pre><code>Follow(who, whom string) error
Unfollow(who, whom string) error
IsFollowing(who, whom string) (bool, error)
Following(who string) ([]string, error)
</code></pre>

<p>These are functions to follow/unfollow, check following and listing
all following users of a user. A user can never follow or unfollow
himself. When calling with <code>who</code> equals to <code>whom</code>, the functions
return error. When the user does not exist, the functions return
error.</p>

<p>A user can follow at most <code>trib.MaxFollowing=2000</code> users. Returns
error when trying to follow more than that.</p>

<hr><pre><code>Home(user string) ([]*Trib, error)
</code></pre>

<p>List the recent <code>trib.MaxTribFetch=100</code> tribbles that are posted on
the user's following timeline in Tribble Order.  In addition, the
order should always satisfy:</p>

<ol>
<li>If a tribble A is posted after a tribble B is posted, and they are
posted by the same user, A always shows after B.</li>
<li>If a tribble A is posted 5 seconds after a tribble B is posted,
even if they are posted by two different users, A always shows after
B.<br>
</li>
<li>If a tribble A is posted after a user client sees tribble B, A
always shows after B.</li>
</ol><p>A is <em>posted after</em> B means B calls <code>Post()</code> after A's <code>Post()</code>
returned.</p>

<p>It returns error when the user does not exist.</p>

<hr><p>In addition to normal errors, it might also return IO errors if the
implementation needs to communicate to a remote part.  Returning a nil
error means that the call is successfully executed; returning a
non-nill error means that the call might be executed or not.</p>

<h2>
<a name="key-value-pair-service-interface" class="anchor" href="#key-value-pair-service-interface"><span class="octicon octicon-link"></span></a>Key-value Pair Service Interface</h2>

<p>Data structure and interfaces for the key-value pair service is
defined in <code>trib/kv.go</code> file. The main interface is <code>trib.Storage</code>
interface, which consists of three parts.</p>

<p>First is the key-value pair part.</p>

<pre><code>// Key-value pair interfaces
// Default value for all keys is empty string
type KeyString interface {
    // Gets a value. Empty string by default.
    Get(key string, value *string) error

    // Set kv.Key to kv.Value. Set succ to true when no error.
    Set(kv *KeyValue, succ *bool) error

    // List all the keys of non-empty pairs where the key matches
    // the given pattern.
    Keys(p *Pattern, list *List) error
}
</code></pre>

<p><code>Pattern</code> is a prefix-suffix tuple. It has a <code>Match(string)</code> function
that returns true when the string matches the pattern.</p>

<p>Second is the key-string pair part.</p>

<pre><code>// Key-list interfaces.
// Default value for all lists is an empty list.
// After the call, list.L should never by nil.
type KeyList interface {
    // Get the list.
    ListGet(key string, list *List) error

    // Append a string to the list, succ will always set to true.
    ListAppend(kv *KeyValue, succ *bool) error

    // Removes all elements that equals to kv.Value in list kv.Key
    // n is set to the number of elements removed.
    ListRemove(kv *KeyValue, n *int) error

    // List all the keys of non-empty lists, where the key matches
    // the given pattern.
    ListKeys(p *Pattern, list *List) error
}
</code></pre>

<p>And finally we put it together with an auto-incrementing clock service:</p>

<pre><code>type Storage interface {
    // Returns an auto-incrementing clock, the returned value
    // will be no smaller than atLeast, and it will be
    // strictly larger than the value returned last time,
    // unless it was math.MaxUint64.
    Clock(atLeast uint64, ret *uint64) error

    KeyString
    KeyList
}
</code></pre>

<p>Note that the function signature of these methods are all RPC
friendly. You should directly implement the RPC inteface with Go
language's RPC package.  By doing this, another person's client that
speaks the same protocol will be able to talk to your server as well.</p>

<p>Under the defintion of the execution logic, all the methods will
always return nil error. Hence all errors you see from this interface
will be communication errors. You can assume that each call (on the
same key) is an atomic transaction; two concurrent writes won't give
the key a weird value out of nowhere.  However, when an error occurs,
the caller won't know if the transaction is commited or not, because
the error might occur before or after the transaction.</p>

<h2>
<a name="entry-functions" class="anchor" href="#entry-functions"><span class="octicon octicon-link"></span></a>Entry Functions</h2>

<p>These are the 3 entry functions you need to implement. This is how
other people's code will use your code.</p>

<pre><code>func ServeBack(b *trib.Back) error
</code></pre>

<p>This function creates an instance of a back-end server based on
configuration <code>b *trib.Back</code>. Structure <code>trib.Back</code> is defined in
<code>trib/config.go</code> file.  In the struct type, it has several fields:</p>

<ul>
<li>
<code>Addr</code> is the address the server should listen on, in the form of
<code>&lt;host&gt;:&lt;port&gt;</code>. Go language uses this address in its <a href="http://golang.org/pkg/net">standard
<code>net</code> package</a>, so you should be able to
use it directly.<br>
</li>
<li>
<code>Store</code> is the storage device you will use for storing stuff. In
fact, You should not store persistent data anywhere else.
<code>Store</code> will never be nil.</li>
<li>
<code>Ready</code> is a channel for notifying the other parts in the program
that the server is ready to accept RPC calls from the network 
(by sending value <code>true</code>) of failed to setup the connection
(by sending value <code>false</code>). <code>Ready</code> might be nil (means the caller
does not care about when it is ready).</li>
</ul><p>This function should be a blocking call. It does not return until an
error (like the network is shutdown) occurred.</p>

<pre><code>func NewClient(addr string) trib.Stroage
</code></pre>

<p>This function takes the addr as a TCP address in the form of
<code>&lt;host&gt;:&lt;port&gt;</code>, and will use that as the server address. It returns
an implementation of <code>trib.Storage</code>. You can assume <code>addr</code> will always
be a valid one.</p>

<pre><code>func NewFront(backs []string) trib.Server
</code></pre>

<p>This function takes the addresses of the backends, and returns an
implementation of <code>trib.Server</code>. The returned instance then will serve
as an service front-end that takes Tribbler service function calls,
and translates them into key-value pair RPC calls. This front-end
should be stateless, thread safe, and ready to be killed at any time.
This means that at any time during its execution, the back-end
key-value pair storage always stays in a consistent state. Also, note
that one front-end might be taking multiple concurrent requests from
the Web, and there might be multiple front-ends talking to the same
back-end, so make sure it handles all the concurrency issues
correctly.</p>

<p>In Lab1, <code>backs</code> will always contain only one address.</p>

<h2>
<a name="rpc" class="anchor" href="#rpc"><span class="octicon octicon-link"></span></a>RPC</h2>

<p>Go language comes with its own
<a href="http://golang.org/pkg/net/rpc"><code>net/rpc</code></a> package in its standard
library, and we will just use that.  Note that the <code>trib.Store</code>
interface is already in its "RPC friendly" form.</p>

<p>Your RPC needs to use the default encoding <code>encoding/gob</code>, listen on
the given address, and serve as an http RPC server. The server 
needs to register the back-end key-value pair object under the
name <code>Storage</code>.</p>

<h2>
<a name="testing" class="anchor" href="#testing"><span class="octicon octicon-link"></span></a>Testing</h2>

<p>Both the <code>trib</code> and <code>triblab</code> repository comes with a makefile with
some handy command lines, and also some basic testing code.</p>

<p>Under the <code>trib</code> directory, if you type <code>make test</code>, you should see
that the tests runs and all passed.</p>

<p>Under the <code>triblab</code> directory, if you type <code>make test</code> however, you
would see the test fails with a todo panic.</p>

<p>Your first attempt should be implement the logic and try to pass those
test cases. If you pass those, you should be fairly confident that you
can get at least 30% of the credits for Lab1 (unless you are cheating
in some way).</p>

<p>However, the test that comes with the repository is very basic and
simple.  Though you don't have to, you should really write more test
cases to make sure your implementation matches the specification.</p>

<p>For more information on writing test cases in Go language, see the
<a href="http://golang.org/pkg/testing/">testing</a> package document page.</p>

<h2>
<a name="starting-hints" class="anchor" href="#starting-hints"><span class="octicon octicon-link"></span></a>Starting Hints</h2>

<p>While you are free to do the project in your own way as long as
it fits the specification, matches the interfaces and passes the 
tests, here are some suggested steps for you to start.</p>

<p>First, create a <code>client.go</code> file under <code>triblab</code> repo, and declare a
new struct type called <code>client</code>:</p>

<pre><code>package triblab

type client struct {
    // your private fields will go here
}
</code></pre>

<p>Then add method functions to this new <code>client</code> type so that 
it matches <code>trib.Storage</code> interface. For example, for the <code>Get()</code>
function:</p>

<pre><code>func (self *client) Get(key string, value *string) error {
    panic("todo")
}
</code></pre>

<p>After you added all the functions, you can write a line for compile
time checking if all the functions are implemented:</p>

<pre><code>var _ trib.Storage = new(client)
</code></pre>

<p>This creates a zero-filled <code>client</code> and assigns it to an anonymous
object of <code>trig.Storage</code> interface. It only compiles when <code>client</code>
satisfies the interface.</p>

<p>Now add a field into <code>client</code> called <code>addr</code>, which will save the
server address. Now <code>client</code> looks like this:</p>

<pre><code>type client struct {
    addr string
}
</code></pre>

<p>Now that we have a client type that satisfies <code>trib.Stroage</code>, we 
can return this type in our entry function <code>NewClient()</code>. So remove
the <code>panic("todo")</code> line in <code>NewClient()</code>, and replace it by
returning a new <code>client</code> object. Now the <code>NewClient()</code> function
should look something like this:</p>

<pre><code>func NewClient(addr string) trib.Storage {
    return &amp;client{addr: addr}
}
</code></pre>

<p>Now we have the code skeleton for the RPC client, and we will fill
in the actual logic of performing RPC calls.</p>

<p>To do an RPC call, we need to use the <code>rpc</code> package, so at the 
start of <code>client.go</code> file, lets import that after the package
name statement.</p>

<pre><code>import (
    "net/rpc"
)
</code></pre>

<p>And following the examples given in the <code>rpc</code> package, we can 
write the RPC client logic. For example, the <code>Get()</code> method
should look something like this:</p>

<pre><code>func (self *client) Get(key string, value *string) error {
    // connect to the server
    conn, e := rpc.DialHTTP("tcp", self.addr)
    if e != nil {
        return e
    }

    // perform the call
    e = conn.Call("Storage.Get", key, value)
    if e != nil {
        conn.Close()
        return e
    }

    // close the connection
    return conn.Close()
}
</code></pre>

<p>However, note that if you do it this way, you will open a new HTTP
connection for every RPC call. It is okay, but it is not the most
efficient way to do it.  I will leave it for yourself to figure out
how to maintain a persistent RPC connection.</p>

<p>That was the client side. You also need to wrap the server side 
in the <code>ServeBack</code> function using the <code>rpc</code> library. This should be
pretty straight-forward by creating an RPC server, registering the
<code>Store</code> fields in <code>b *trib.Config</code> parameter under the name of
<code>Storage</code>, and serving it as an HTTP server. The code should be
similar to one of the examples given in the
<a href="http://golang.org/pkg/net/rpc"><code>rpc</code></a> package documentation. Just
remember that you need to register as <code>Storage</code> and also need to send
a <code>true</code> over the <code>Ready</code> channel (if the <code>Ready</code> is not <code>nil</code>) when
the service is ready, but send a <code>false</code> when you encounter any error
on starting your service.</p>

<p>When all of those are done, you should pass the test cases written in
<code>back_test.go</code> file. It calls the <code>CheckStorage()</code> function defined
in <code>trib/tribtest</code> package, and performs some basic checks on if an
RPC client and a server (that runs on the same host) will satisfy the
specification of a key-value pair service (as a local
<code>trib/store.Storage</code> will but without RPC).</p>

<h2>
<a name="playing-with-it" class="anchor" href="#playing-with-it"><span class="octicon octicon-link"></span></a>Playing with It</h2>

<p>To run your own implementation, you could use the <code>trib-front</code> and
<code>trib-back</code> launcher.</p>

<p>First make sure you code compiles.</p>

<p>Then run the back-end server.</p>

<pre><code>$ trib-back
</code></pre>

<p><em>(You might need to add <code>$PATH</code> before you do so.)</em></p>

<p>And you should see an address printing out, say it is
<code>localhost:37021</code>.  Note that you can also specify your own address
via command line. The default is <code>localhost:rand</code>.</p>

<p>Next for the front-end part. Run on the same machine (since it is
listening on <code>localhost</code>).</p>

<pre><code>$ trib-front -init -lab -back=localhost:37021
</code></pre>

<p>For the <code>-back</code> flag, please use the backend address that you just got
from running <code>trib-back</code>.</p>

<p><code>-init</code> will populate the service with some sample data.  <code>-lab</code> tells
the front-end to connect to a back-end rather than running with the
default reference implementation.</p>

<p>Now you can open your browser, connect to the front-end machine and
play with your own implementation.</p>

<p>Note that, when you completes Lab1, it should be perfectly fine to
have multiple front-ends that connects to a single back-end.</p>

<h2>
<a name="requirements" class="anchor" href="#requirements"><span class="octicon octicon-link"></span></a>Requirements</h2>

<ul>
<li>When the network and the storage is errorless, RPC to your back-end
should not return any error, and valid function calls to the
Tribbler front-end service should not any error.</li>
<li>When the network or storage has error on the back-end (which you
might not tell the difference), the front-end should handle them
correctly. The system should always be kept in a consistent state.</li>
<li>When running on the lab machines, every function call to the
Tribbler front-end service should return within 1 second.</li>
</ul><h2>
<a name="common-mistakes" class="anchor" href="#common-mistakes"><span class="octicon octicon-link"></span></a>Common Mistakes</h2>

<p>Here are some common mistakes that a lazy and quick
but incorrect implementation might do:</p>

<ul>
<li>
<strong>Read-modify-write</strong>. For example, a tribbler might read a counter
from the key-value store, increase it by one and then write it back
(at the same key).  This will introduce racing condition among the
front-ends.</li>
<li>
<strong>Not handling errors</strong>. A tribbler service call might require
several RPC calls to the backend. It is important to properly handle
<em>any</em> error returned by these calls.</li>
<li>
<strong>Sorting by the timestamps first</strong>. Again, Tribble Order means that
the logic clock is the first field to consider on sorting. </li>
<li>
<strong>Use the clock argument from the front-end for the clock field of a
new Tribble</strong>. Well, technically, you can do that in your code
internally as long as you can satisfy the ordering requirements
speficied for <code>Home()</code> and <code>Tribs()</code> (you might find it very hard).
Nonetheless, intuitively, the clock argument tells the <em>oldest</em>
tribble a user have seen (which might be 0 if the user has not seen
any tribble yet), hence the new posted tribble seems to better have
a clock value that is larger than the argument.</li>
<li>
<strong>Generate the clock from the timestamp</strong>. While 64-bit can cover a
very wide time range even in the unit of nanoseconds, you should
keep in mind that the front-ends are running on different servers
with arbitrary physical time differences, so it is not wise to
generate the logical <em>clock</em> from the physical <em>time</em>.</li>
<li>
<strong>Not handling old tribbles</strong>. Note that only the most recent 100
tribbles of a user matter. Not handling old tribbles might lead to
worse and worse performance over time and eventually break the
performance promise.</li>
</ul><h2>
<a name="turning-in" class="anchor" href="#turning-in"><span class="octicon octicon-link"></span></a>Turning In</h2>

<p>First, make sure every piece of your code is commited into the
repository in <code>triblab</code>. Then just type <code>make turnin</code> under the root
of the repository.  It will generate a <code>turnin.zip</code> that contains
everything in your git repository, and then copy the zip file to a
place where only the lab instructors can read.</p>

<h2>
<a name="happy-lab1" class="anchor" href="#happy-lab1"><span class="octicon octicon-link"></span></a>Happy Lab1!</h2>
